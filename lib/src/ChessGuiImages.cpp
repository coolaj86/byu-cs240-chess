// Author: Owen Merkling,,, <omerkling@gmail.com>, (C) 2008
//
// Copyright: For use by the students of CS 240 at BYU
//
//

#include <gtkmm/stock.h>
#include "ChessGuiImages.h"
///@file Inline.h Generated by gdk-pixbuf-csource
///
///Contains Global definitions of pixbuf inline data.  Should not be included more than once or could cause compile errors
#include "Inline.h"


std::vector<Glib::RefPtr<Gdk::Pixbuf> > ChessGuiImages::images;
std::vector<std::string> ChessGuiImages::imagePaths;
Glib::RefPtr<Gdk::Pixbuf> ChessGuiImages::error;

bool ChessGuiImages::loaded=false;


void ChessGuiImages::LoadDefaultImages()
{
	
	g_debug("ChessGuiImages::LoadDefaultImages");
	LoadImages("images");
	return;	
}
void ChessGuiImages::LoadImages(const std::string & path)
{
	g_debug("ChessGuiImages::LoadImages");
        error=Gdk::Pixbuf::create_from_inline(-1,ImageError,false);
	SetDefaultFileNames();
	CombinePathAndFileName(path);
	LoadImageFiles();

	return;
}

bool ChessGuiImages::Loaded()
{
	return loaded;
}

bool ChessGuiImages::isLoaded(ImageName image)
{
	return (loaded && images[image]!=images[NO_IMAGE]);	
}


void ChessGuiImages::LoadImage(const std::string & path, ImageName image)
{
	g_debug("ChessGuiImages::LoadImage");
	
	std::string file;
	if(image<(signed int)imagePaths.size() && image<NUM_IMAGE_NAMES)
	{
		file=imagePaths[image];
	
		try
		{
			if(file.length()>0)
			{
				images[image]=Gdk::Pixbuf::create_from_file(file);
			}
		}
		catch(...)//what exception does pixbuf throw?
		{
			g_warning("Could Not Load Image %s",file.c_str());			
			images[image]=images[NO_IMAGE];
		}
	}
	
	
	return;
}


const Glib::RefPtr<Gdk::Pixbuf> & ChessGuiImages::GetImage(ImageName image)
{
	if(images.size()!=NUM_IMAGE_NAMES)
		LoadDefaultImages();
	
	if(images[image]!=0)
		return images[image];
	else
		return images[NO_IMAGE];
	
}

const Glib::RefPtr<Gdk::Pixbuf> & ChessGuiImages::GetErrorImage()
{
     if(error!=0)
	return error;
     else
          return GetImage(NO_IMAGE);
}

/**************************************************************************Internal**/
void ChessGuiImages::SetDefaultFileNames()
{
	///@todo make extension independent
	imagePaths.resize(NUM_IMAGE_NAMES);
	imagePaths[NO_IMAGE] ="";
	imagePaths[BACK_GRND]="background.xpm";
	imagePaths[WHITE_TILE]="wtile.png";
	imagePaths[BLACK_TILE]="btile.png";
	imagePaths[W_PAWN] = "wpawn.png";
	imagePaths[B_PAWN] = "bpawn.png";
	imagePaths[W_BISHOP] = "wbishop.png";
	imagePaths[B_BISHOP] = "bbishop.png";
	imagePaths[W_KNIGHT] = "wknight.png";
	imagePaths[B_KNIGHT] = "bknight.png";
	imagePaths[W_ROOK] = "wrook.png";
	imagePaths[B_ROOK] = "brook.png";
	imagePaths[W_KING] = "wking.png";
	imagePaths[B_KING] = "bking.png";
	imagePaths[W_QUEEN] = "wqueen.png";
	imagePaths[B_QUEEN] = "bqueen.png";
	
}
void ChessGuiImages::CombinePathAndFileName(std::string path)
{
	if(path.length()==0)
		return;
	//check for trailing '/'
	if(path.at(path.length()-1)!='/')
	{
		path.append(1,'/');	
	}
	
	
	for(unsigned int i = NO_IMAGE; i<NUM_IMAGE_NAMES ;i++)
	{
		if(imagePaths[i].length()!=0)
		{
			//remove any leading '/'
			while(imagePaths[i].at(0)=='/')
			{
				imagePaths[i].erase(0,1);
			}
			
			imagePaths[i]=std::string(path+imagePaths[i]);
		}
	}
}

void ChessGuiImages::LoadImageFiles()
{
	try
	{
		images.resize(NUM_IMAGE_NAMES, Glib::RefPtr<Gdk::Pixbuf>(0));
		
		
		images[NO_IMAGE] = Gdk::Pixbuf::create(Gdk::COLORSPACE_RGB, true,BITS_PER_SAMPLE,DEFAULT_CELL_SIZE,DEFAULT_CELL_SIZE);
		images[NO_IMAGE]->fill(CLEAR_SQUARE);
		
		
		for(unsigned int i = 0; i<NUM_IMAGE_NAMES;i++)
		{
			LoadImage(imagePaths[i],(ImageName)i);
		}
		SetTilePatternImages();
	}
	catch(...)
	{
		g_warning("Error Loading Images");
		loaded=false;
		return;
	}
	loaded=true;
	return;
}


void ChessGuiImages::SetTilePatternImages()
{
	if(images.size()!=NUM_IMAGE_NAMES)
		LoadDefaultImages();
	
	
	if(images[BLACK_TILE]==images[NO_IMAGE] || images[BLACK_TILE]==0)
	{
		//create a black pixbuf
		images[BLACK_TILE] = Gdk::Pixbuf::create(Gdk::COLORSPACE_RGB,
				true,images[BACK_GRND]->get_bits_per_sample(),
						DEFAULT_CELL_SIZE,DEFAULT_CELL_SIZE);
		images[BLACK_TILE]->fill(BLACK_SQUARE);
	}
	if(images[WHITE_TILE]==images[NO_IMAGE] || images[WHITE_TILE]==0)
	{
		//create a black pixbuf
		images[WHITE_TILE] = Gdk::Pixbuf::create(Gdk::COLORSPACE_RGB,
				true,images[BACK_GRND]->get_bits_per_sample(),
						DEFAULT_CELL_SIZE,DEFAULT_CELL_SIZE);
		
		images[WHITE_TILE]->fill(WHITE_SQUARE);
	}
	
}
